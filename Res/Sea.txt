#version 120uniform int     iter_geometry;uniform int     iter_fragment;uniform float   height;uniform float   choppy;uniform float   speed;uniform float   frequency;uniform float   iTime;uniform vec2    viewport;uniform vec3    baseColor;uniform vec3    waterColor;uniform mat4    prjInvMat;uniform mat4    mdlInvMat;/* * "Seascape" by Alexander Alekseev aka TDM - 2014 * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. * Contact: tdmaav@gmail.com */const int NUM_STEPS = 8;const float PI	 	= 3.141592;const float EPSILON	= 1e-3;// sea//const int iter_geometry = 5;//const int iter_fragment = 3;//const float height = 0.6;//const float choppy = 6.0;//const float speed = 0.8;//const float frequency = 0.16;//const vec3 baseColor = vec3(0.1,0.19,0.22);//const vec3 waterColor = vec3(0.5,1,0.6);const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);vec3 yztozy(vec3 p){    return vec3(p.x,p.z,p.y);}void setupCamera(vec2 uv,out vec3 campos, out vec3 dir){     vec4 camdir = vec4(uv,1,1)*prjInvMat;     camdir = camdir/camdir.w;     vec4 camv = vec4(0,0,0,1);     camv = camv*mdlInvMat;     campos = camv.xyz;     vec4 dirp = camdir*mdlInvMat;     dir = normalize((dirp-camv).xyz);}float hash( vec2 p ) {	float h = dot(p,vec2(127.1,311.7));	    return fract(sin(h)*43758.5453123);}float noise( in vec2 p ) {    vec2 i = floor( p );    vec2 f = fract( p );		vec2 u = f*f;//f*f*(2.0-f);    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ),                      hash( i + vec2(1.0,0.0) ), u.x),                mix( hash( i + vec2(0.0,1.0) ),                      hash( i + vec2(1.0,1.0) ), u.x), u.y);}// lightingfloat diffuse(vec3 n,vec3 l,float p) {    return pow(dot(n,l) * 0.4 + 0.6,p);}float specular(vec3 n,vec3 l,vec3 e,float s) {        float nrm = (s + 8.0) / (PI * 8.0);    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;}// skyvec3 getSkyColor(vec3 e) {    e.y = max(e.y,0.0);    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);}// seafloat sea_octave(vec2 uv, float choppy) {    uv += noise(uv);            vec2 wv = 1.0-abs(sin(uv));    vec2 swv = abs(cos(uv));        wv = mix(wv,swv,wv);    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);}float map(vec3 p) {    float freq = frequency;    float amp = height;    float choppy = choppy;    vec2 uv = p.xz;        float d, h = 0.0;        for(int i = 0; i < iter_geometry; i++) {            	d = sea_octave((uv+(1.0 + iTime * speed))*freq,choppy);    	d += sea_octave((uv-(1.0 + iTime * speed))*freq,choppy);        h += d * amp;            	uv *= octave_m; freq *= 1.9; amp *= 0.22;        choppy = mix(choppy,1.0,0.2);    }    return (p.y - h)*0.1;}float map_detailed(vec3 p) {    float freq = frequency;    float amp = height;    float choppy = choppy;    vec2 uv = p.xz; uv.x *= 0.75;        float d, h = 0.0;        for(int i = 0; i < iter_fragment; i++) {            	d = sea_octave((uv+(1.0 + iTime * speed))*freq,choppy);    	d += sea_octave((uv-(1.0 + iTime * speed))*freq,choppy);        h += d * amp;            	uv *= octave_m; freq *= 1.9; amp *= 0.22;        choppy = mix(choppy,1.0,0.2);    }    return p.y - h;}vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {      float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);    fresnel = pow(fresnel,3.0) * 0.65;            vec3 reflected = getSkyColor(reflect(eye,n));        vec3 refracted = baseColor + diffuse(n,l,80.0) * waterColor * 0.12;         vec3 color = mix(refracted,reflected,fresnel);        float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);    color += waterColor * (p.y - height) * 0.18 * atten;        color += vec3(specular(n,l,eye,60.0));        return color;}// tracingvec3 getNormal(vec3 p, float eps) {    vec3 n;    n.y = map_detailed(p);        n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;    n.y = eps;    return normalize(n);}float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {      float tm = 0.0;    float tx = 1000.0;        float hx = map(ori + dir * tx);    if(hx > 0.0) return tx;       float hm = map(ori + dir * tm);        float tmid = 0.0;    for(int i = 0; i < NUM_STEPS; i++) {        tmid = mix(tm,tx, hm/(hm-hx));                           p = ori + dir * tmid;                       	float hmid = map(p);		if(hmid < 0.0) {        	tx = tmid;            hx = hmid;        } else {            tm = tmid;            hm = hmid;        }    }    return tmid;}// mainvoid main() {	vec2 uv = gl_FragCoord.xy / viewport;    uv = uv * 2.0 - 1.0;        float time = iTime;     // float ttm = mod(time*100.0,100.0);    // ray        vec3 pos,ray;    setupCamera(uv,pos,ray);    pos = yztozy(pos);    ray = yztozy(ray);        // tracing    vec3 p;    heightMapTracing(pos,ray,p);    vec3 dist = p - pos;    vec3 n = getNormal(p, dot(dist,dist) * (0.1 / viewport.x));    vec3 light = yztozy(gl_LightSource[0].position.xyz);                  // color    vec3 color = mix(        getSkyColor(ray),        getSeaColor(p,n,light,ray,dist),    	pow(smoothstep(0.0,-0.05,ray.y),0.3));            	gl_FragColor = vec4(pow(color,vec3(0.5)), 1.0);	}